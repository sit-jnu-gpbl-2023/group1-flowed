{"README.md":"# environment\n\nEnvironment and Science IoT package is developed under the cooperation of [ELECFREAKS](https://www.elecfreaks.com/), [CLASSROOM](http://www.classroom.com.hk/) and [TINKERCADEMY](https://tinkercademy.com/).\n\nThe ELECFREAKS Environment and Science IoT Kit can detect all kinds of environment data like temperature, humidity, wind speed, light intensity, noise, dust, and PM2.5 level. In addition, you can upload these environment data to the [Thingspeak](https://thingspeak.com) IoT server (free registration required), using the [ESP8266 serial wifi module](http://www.elecfreaks.com/estore/esp8266-serial-wifi-module.html). \n\n![](https://github.com/elecfreaks/pxt-environment/blob/master/microbit_CEO_and_Environment_Kit.jpg)\n\n## Hardware list \n\n1. [ELECFREAKS Octopus:bit](http://www.elecfreaks.com/estore/elecfreaks-micro-bit-breakout-board.html).\n2. [IIC OLED display](http://www.elecfreaks.com/estore/iic-oled.html)\n3. [Sound Sensor](http://www.elecfreaks.com/estore/octopus-analog-noise-sound-sensor-detection-module.html)\n4. [Octopus Temperature And Humidity Sensor](http://www.elecfreaks.com/estore/octopus-temperature-and-humidity-sensor.html)\n5. [Octopus Soil Moisture Sensor](http://www.elecfreaks.com/estore/octopus-soil-moisture-sensor-brick.html)\n6. [Octopus Analog Photocell](http://www.elecfreaks.com/estore/octopus-analog-photocell-brick-obphotocell.html)\n7. [Dust Sensor](http://www.elecfreaks.com/estore/octopus-dust-sensor-detector-module-with-sharp-gp2y1010au0f.html)\n8. [PM2.5/PM10](http://www.elecfreaks.com/estore/octopus-pm2-5-pm10-detector-sensor-module-optical-dust-sensor-air-conditioner-monitor.html)\n9. [Win Sensor](http://www.elecfreaks.com/estore/wind-speed-sensor-anemometer-three-aluminium-cups.html)\n10. [ESP8266 Serial Wifi Module](http://www.elecfreaks.com/estore/esp8266-serial-wifi-module.html)\n\n## Basic usage\n\n1. Open [Microsoft Makecode/microbit](https://pxt.microbit.org) and create a new project \n2. Search and add the `environment` package\n3. Use the `Environment_IoT` drawer in the editor to drag out and arrange the blocks\n4. Click `Download` to move your program to the micro:bit\n\n## Example\n\n### dust sensor init\nInitialize dust sensor. Set pin vLED and VO.\n```blocks\nEnvironment_IoT.initdust(DigitalPin.P10, AnalogPin.P1)\n```\n\n### read dust\nget dust(μg/m³) \n```blocks\nEnvironment_IoT.initdust(DigitalPin.P10, AnalogPin.P1)\nbasic.forever(() => {\n    basic.showNumber(Environment_IoT.ReadDust())\n})\n```\n\n### read temperature\nget DHT11 Temperature(℃)\n```blocks\nbasic.forever(() => {\n    basic.showNumber(Environment_IoT.ReadTemperature(AnalogPin.P0))\n})\n```\n\n### read PM2.5\nget pm2.5(μg/m³)\n```blocks\nbasic.forever(() => {\n    basic.showNumber(Environment_IoT.ReadPM25(DigitalPin.P11))\n})\n``` \n\n### read PM10\nget pm10(μg/m³)\n```blocks\nbasic.forever(() => {\n    basic.showNumber(Environment_IoT.ReadPM10(DigitalPin.P12))\n})\n```\n\n### read soil moisture\nget soil moisture, Value Range: 0~100.\n```blocks\nbasic.forever(() => {\n    basic.showNumber(Environment_IoT.ReadSoilHumidity(AnalogPin.P3))\n})\n```\n\n### read wind speed\nget wind speed(m/s)\n```blocks\nbasic.forever(() => {\n    basic.showNumber(Environment_IoT.ReadWindSpeed(AnalogPin.P4))\n})\n```\n\n\n## License\n\nMIT\n\n\n## Supported targets\n\n* for PXT/microbit\n(The metadata above is needed for package search.)\n\n```package\nenvironment=github:sunnyrainwss/pxt-iot-environment-kit\niot=github:sunnyrainwss/pxt-iot-environment-kit\n```\n\n\n\n","_locales/zh/Environment-and-Science-IoT-strings.json":"{\n  \"Environment.BME280_state.BME280_altitude|block\": \"高度(M)\",\n  \"Environment.BME280_state.BME280_humidity|block\": \"湿度(0~100)\",\n  \"Environment.BME280_state.BME280_pressure|block\": \"气压(hPa)\",\n  \"Environment.BME280_state.BME280_temperature_C|block\": \"温度(℃)\",\n  \"Environment.DHT11Type.DHT11_humidity|block\": \"湿度(0~100)\",\n  \"Environment.DHT11Type.DHT11_temperature_C|block\": \"摄氏温度(℃)\",\n  \"Environment.DHT11Type.DHT11_temperature_F|block\": \"华氏温度(℉)\",\n  \"Environment.Distance_Unit.Distance_Unit_cm|block\": \"厘米\",\n  \"Environment.Distance_Unit.Distance_Unit_inch|block\": \"英尺\",\n  \"Environment.Distance_Unit.Distance_Unit_mm|block\": \"毫米\",\n  \"Environment.Distance_Unit_List.Distance_Unit_cm|block\": \"厘米\",\n  \"Environment.Distance_Unit_List.Distance_Unit_inch|block\": \"英尺\",\n  \"Environment.Ds18b20Temp|block\": \"DS18B20 温度传感器 %state 连接至 %pin\",\n  \"Environment.PIR|block\": \"人体红外传感器 %Rjpin 监测到移动\",\n  \"Environment.ReadDust|block\": \"连接至 LED %vLED| out %vo 的灰尘量(μg/m³)\",\n  \"Environment.ReadLightIntensity|block\": \"连接至 %lightintensitypin 的光线值(0~100)\",\n  \"Environment.ReadNoise|block\": \"连接至 %noisepin 的噪音值(dB)\",\n  \"Environment.ReadPM10|block\": \"连接至 %pm10pin 的 pm10(μg/m³) 值\",\n  \"Environment.ReadPM25|block\": \"连接至 %pm25pin 的 pm2.5(μg/m³) 值\",\n  \"Environment.ReadSoilHumidity|block\": \"连接至 %soilhumiditypin 的土壤湿度值(0~100)\",\n  \"Environment.ReadWaterLevel|block\": \"连接至 %waterlevelpin 的雨量值(0~100)\",\n  \"Environment.ReadWindSpeed|block\": \"连接至 %windspeedpin 的风速值(m/s)\",\n  \"Environment.UVLevel|block\": \"紫外线传感器 %Rjpin 强度(0~15)\",\n  \"Environment.ValType.DS18B20_temperature_C|block\": \"摄氏温度(℃)\",\n  \"Environment.ValType.DS18B20_temperature_F|block\": \"华氏温度(℉)\",\n  \"Environment.dht11value|block\":  \"DHT11传感器的 %dht11type|值 连接至 %dht11pin\",\n  \"Environment.ledBrightness|block\": \"LED %pin 切换到 $ledstate || 亮度 %brightness \\\\%\",\n  \"Environment.octopus_BME280|block\": \"BME280传感器 的 %state 值\",\n  \"Environment.sonarbit_distance|block\": \"超声波测距单位 %distance_unit |连接至 %pin 的距离值\",\n  \"Environment.readDataBlock|block\": \"RFID 传感器 IIC接口 从卡中读取数据\",\n  \"Environment.writeData|block\": \"RFID 传感器 IIC接口 将数据 %data 写入卡\",\n  \"Environment.checkCard|block\": \"RFID 传感器 IIC接口 检测到卡片\",\n  \"Environment|block\": \"八爪鱼环境模块\",\n  \"{id:category}Environment\": \"八爪鱼环境模块\"\n}","environment.ts":"/**\n * Custom blocks\n */\n//% color=#ff7a4b icon=\"\\uf0ee\" block=\"Octopus\"\nnamespace Environment {\n\n    let weatherMonitorStarted = false;\n    // BME280 Addresses\n    let BME280_I2C_ADDR = 0x76\n    let dig_T1 = getUInt16LE(0x88)\n    let dig_T2 = getInt16LE(0x8A)\n    let dig_T3 = getInt16LE(0x8C)\n    let dig_P1 = getUInt16LE(0x8E)\n    let dig_P2 = getInt16LE(0x90)\n    let dig_P3 = getInt16LE(0x92)\n    let dig_P4 = getInt16LE(0x94)\n    let dig_P5 = getInt16LE(0x96)\n    let dig_P6 = getInt16LE(0x98)\n    let dig_P7 = getInt16LE(0x9A)\n    let dig_P8 = getInt16LE(0x9C)\n    let dig_P9 = getInt16LE(0x9E)\n    let dig_H1 = getreg(0xA1)\n    let dig_H2 = getInt16LE(0xE1)\n    let dig_H3 = getreg(0xE3)\n    let a = getreg(0xE5)\n    let dig_H4 = (getreg(0xE4) << 4) + (a % 16)\n    let dig_H5 = (getreg(0xE6) << 4) + (a >> 4)\n    let dig_H6 = getInt8LE(0xE7)\n    let T = 0\n    let P = 0\n    let H = 0\n    setreg(0xF2, 0x04)\n    setreg(0xF4, 0x2F)\n    setreg(0xF5, 0x0C)\n    setreg(0xF4, 0x2F)\n\n    // Stores compensation values for Temperature (must be read from BME280 NVM)\n    let digT1Val = 0\n    let digT2Val = 0\n    let digT3Val = 0\n\n    // Stores compensation values for humidity (must be read from BME280 NVM)\n    let digH1Val = 0\n    let digH2Val = 0\n    let digH3Val = 0\n    let digH4Val = 0\n    let digH5Val = 0\n    let digH6Val = 0\n\n    // Buffer to hold pressure compensation values to pass to the C++ compensation function\n    let digPBuf: Buffer\n\n    // BME Compensation Parameter Addresses for Temperature\n    const digT1 = 0x88\n    const digT2 = 0x8A\n    const digT3 = 0x8C\n\n    // BME Compensation Parameter Addresses for Pressure\n    const digP1 = 0x8E\n    const digP2 = 0x90\n    const digP3 = 0x92\n    const digP4 = 0x94\n    const digP5 = 0x96\n    const digP6 = 0x98\n    const digP7 = 0x9A\n    const digP8 = 0x9C\n    const digP9 = 0x9E\n\n    // BME Compensation Parameter Addresses for Humidity\n    const digH1 = 0xA1\n    const digH2 = 0xE1\n    const digH3 = 0xE3\n    const e5Reg = 0xE5\n    const e4Reg = 0xE4\n    const e6Reg = 0xE6\n    const digH6 = 0xE7\n\n    let Reference_VOLTAGE = 3100\n\n    export enum DHT11Type {\n        //% block=\"temperature(℃)\" enumval=0\n        DHT11_temperature_C,\n\n        //% block=\"temperature(℉)\" enumval=1\n        DHT11_temperature_F,\n\n        //% block=\"humidity(0~100)\" enumval=2\n        DHT11_humidity,\n    }\n\n\n    export enum Distance_Unit {\n        //% block=\"mm\" enumval=0\n        Distance_Unit_mm,\n\n        //% block=\"cm\" enumval=1\n        Distance_Unit_cm,\n\n        //% block=\"inch\" enumval=2\n        Distance_Unit_inch,\n    }\n\n\n    export enum BME280_state {\n        //% block=\"temperature(℃)\" enumval=0\n        BME280_temperature_C,\n\n        //% block=\"humidity(0~100)\" enumval=1\n        BME280_humidity,\n\n        //% block=\"pressure(hPa)\" enumval=2\n        BME280_pressure,\n\n        //% block=\"altitude(M)\" enumval=3\n        BME280_altitude,\n    }\n\t\n\n    function setreg(reg: number, dat: number): void {\n        let buf = pins.createBuffer(2);\n        buf[0] = reg;\n        buf[1] = dat;\n        pins.i2cWriteBuffer(BME280_I2C_ADDR, buf);\n    }\n\n    function getreg(reg: number): number {\n        pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt8BE);\n    }\n\n    function getInt8LE(reg: number): number {\n        pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int8LE);\n    }\n\n    function getUInt16LE(reg: number): number {\n        pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt16LE);\n    }\n\n    function getInt16LE(reg: number): number {\n        pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int16LE);\n    }\n    function get(): void {\n        let adc_T = (getreg(0xFA) << 12) + (getreg(0xFB) << 4) + (getreg(0xFC) >> 4)\n        let var1 = (((adc_T >> 3) - (dig_T1 << 1)) * dig_T2) >> 11\n        let var2 = (((((adc_T >> 4) - dig_T1) * ((adc_T >> 4) - dig_T1)) >> 12) * dig_T3) >> 14\n        let t = var1 + var2\n        T = ((t * 5 + 128) >> 8) / 100\n        var1 = (t >> 1) - 64000\n        var2 = (((var1 >> 2) * (var1 >> 2)) >> 11) * dig_P6\n        var2 = var2 + ((var1 * dig_P5) << 1)\n        var2 = (var2 >> 2) + (dig_P4 << 16)\n        var1 = (((dig_P3 * ((var1 >> 2) * (var1 >> 2)) >> 13) >> 3) + (((dig_P2) * var1) >> 1)) >> 18\n        var1 = ((32768 + var1) * dig_P1) >> 15\n        if (var1 == 0)\n            return; // avoid exception caused by division by zero\n        let adc_P = (getreg(0xF7) << 12) + (getreg(0xF8) << 4) + (getreg(0xF9) >> 4)\n        let _p = ((1048576 - adc_P) - (var2 >> 12)) * 3125\n        _p = (_p / var1) * 2;\n        var1 = (dig_P9 * (((_p >> 3) * (_p >> 3)) >> 13)) >> 12\n        var2 = (((_p >> 2)) * dig_P8) >> 13\n        P = _p + ((var1 + var2 + dig_P7) >> 4)\n        let adc_H = (getreg(0xFD) << 8) + getreg(0xFE)\n        var1 = t - 76800\n        var2 = (((adc_H << 14) - (dig_H4 << 20) - (dig_H5 * var1)) + 16384) >> 15\n        var1 = var2 * (((((((var1 * dig_H6) >> 10) * (((var1 * dig_H3) >> 11) + 32768)) >> 10) + 2097152) * dig_H2 + 8192) >> 14)\n        var2 = var1 - (((((var1 >> 15) * (var1 >> 15)) >> 7) * dig_H1) >> 4)\n        if (var2 < 0) var2 = 0\n        if (var2 > 419430400) var2 = 419430400\n        H = (var2 >> 12) / 1024\n    }\n\n    ////////////////////////////////////////////////////////NFC////////////////////////////////////////////\n    let NFC_I2C_ADDR = (0x48 >> 1);\n    let recvBuf = pins.createBuffer(32);\n    let recvAck = pins.createBuffer(8);\n    let ackBuf = pins.createBuffer(6);\n    let uId = pins.createBuffer(4);\n    let passwdBuf = pins.createBuffer(6);\n    let blockData = pins.createBuffer(16);\n    let NFC_ENABLE = 0;\n    const block_def = 1;\n    ackBuf[0] = 0x00;\n    ackBuf[1] = 0x00;\n    ackBuf[2] = 0xFF;\n    ackBuf[3] = 0x00;\n    ackBuf[4] = 0xFF;\n    ackBuf[5] = 0x00;\n    passwdBuf[0] = 0xFF;\n    passwdBuf[1] = 0xFF;\n    passwdBuf[2] = 0xFF;\n    passwdBuf[3] = 0xFF;\n    passwdBuf[4] = 0xFF;\n    passwdBuf[5] = 0xFF;\n    function writeAndReadBuf(buf: Buffer, len: number) {\n        pins.i2cWriteBuffer(NFC_I2C_ADDR, buf);\n        basic.pause(100);\n        recvAck = pins.i2cReadBuffer(NFC_I2C_ADDR, 8);\n        basic.pause(100);\n        recvBuf = pins.i2cReadBuffer(NFC_I2C_ADDR, len - 4);\n    }\n    function checkDcs(len: number): boolean {\n        let sum = 0, dcs = 0;\n        for (let i = 1; i < len - 2; i++) {\n            if ((i === 4) || (i === 5)) {\n                continue;\n            }\n            sum += recvBuf[i];\n        }\n        dcs = 0xFF - (sum & 0xFF);\n        if (dcs != recvBuf[len - 2]) {\n            return false;\n        }\n        return true;\n    }\n    function passwdCheck(id: Buffer, st: Buffer): boolean {\n        let buf: number[] = [];\n        buf = [0x00, 0x00, 0xFF, 0x0F, 0xF1, 0xD4, 0x40, 0x01, 0x60, 0x07, 0xFF,\n            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD1, 0xAA, 0x40, 0xEA, 0xC2, 0x00];\n        let cmdPassWord = pins.createBufferFromArray(buf);\n        let sum = 0, count = 0;\n        cmdPassWord[9] = block_def;\n        for (let i = 10; i < 16; i++)\n            cmdPassWord[i] = st[i - 10];\n        for (let i = 16; i < 20; i++)\n            cmdPassWord[i] = id[i - 16];\n        for (let i = 0; i < 20; i++) {\n            if (i === 3 || i === 4) {\n                continue;\n            }\n            sum += cmdPassWord[i];\n        }\n        cmdPassWord[20] = 0xff - (sum & 0xff)\n        writeAndReadBuf(cmdPassWord, 15);\n        for (let i = 0; i < 4; i++) {\n            if (recvAck[1 + i] != ackBuf[i]) {\n                serial.writeLine(\"psd ack ERROR!\");\n                return false;\n            }\n        }\n        if ((recvBuf[6] === 0xD5) && (recvBuf[7] === 0x41) && (recvBuf[8] === 0x00) && (checkDcs(15 - 4))) {\n            return true;\n        }\n        return false;\n    }\n    function wakeup() {\n        basic.pause(100);\n        let i = 0;\n        let buf: number[] = [];\n        buf = [0x00, 0x00, 0xFF, 0x05, 0xFB, 0xD4, 0x14, 0x01, 0x14, 0x01, 0x02, 0x00];\n        let cmdWake = pins.createBufferFromArray(buf);\n        writeAndReadBuf(cmdWake, 14);\n        for (i = 0; i < ackBuf.length; i++) {\n            if (recvAck[1 + i] != ackBuf[i]) {\n                break;\n            }\n        }\n        if ((i != ackBuf.length) || (recvBuf[6] != 0xD5) || (recvBuf[7] != 0x15) || (!checkDcs(14 - 4))) {\n            NFC_ENABLE = 0;\n        } else {\n            NFC_ENABLE = 1;\n        }\n        basic.pause(100);\n    }\n    function writeblock(data: Buffer): void {\n        if (!passwdCheck(uId, passwdBuf))\n            return;\n        let cmdWrite: number[] = [0x00, 0x00, 0xff, 0x15, 0xEB, 0xD4, 0x40, 0x01, 0xA0,\n            0x06, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xCD,\n            0x00];\n        let sum = 0, count = 0;\n        cmdWrite[9] = block_def;\n        for (let i = 10; i < 26; i++)\n            cmdWrite[i] = data[i - 10];\n        for (let i = 0; i < 26; i++) {\n            if ((i === 3) || (i === 4)) {\n                continue;\n            }\n            sum += cmdWrite[i];\n        }\n        cmdWrite[26] = 0xff - (sum & 0xff);\n        let tempbuf = pins.createBufferFromArray(cmdWrite)\n        writeAndReadBuf(tempbuf, 16);\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////\n\n    let sc_byte = 0\n    let dat = 0\n    let low = 0\n    let high = 0\n    let temp = 0\n    let temperature = 0\n    let ack = 0\n    let lastTemp = 0\n    export enum ValType {\n        //% block=\"temperature(℃)\" enumval=0\n        DS18B20_temperature_C,\n\n        //% block=\"temperature(℉)\" enumval=1\n        DS18B20_temperature_F\n    }\n    function init_18b20(mpin:DigitalPin) {\n        pins.digitalWritePin(mpin, 0)\n        control.waitMicros(600)\n        pins.digitalWritePin(mpin, 1)\n        control.waitMicros(30)\n        ack = pins.digitalReadPin(mpin)\n        control.waitMicros(600)\n        return ack\n    }\n    function write_18b20 (mpin:DigitalPin,data: number) {\n        sc_byte = 0x01\n        for (let index = 0; index < 8; index++) {\n            pins.digitalWritePin(mpin, 0)\n            if (data & sc_byte) {\n                pins.digitalWritePin(mpin, 1)\n                control.waitMicros(60)\n            } else {\n                pins.digitalWritePin(mpin, 0)\n                control.waitMicros(60)\n            }\n            pins.digitalWritePin(mpin, 1)\n            data = data >> 1\n        }\n    }\n    function read_18b20 (mpin:DigitalPin) {\n        dat = 0x00\n        sc_byte = 0x01\n        for (let index = 0; index < 8; index++) {\n            pins.digitalWritePin(mpin, 0)\n            pins.digitalWritePin(mpin, 1)\n            if (pins.digitalReadPin(mpin)) {\n                dat = dat + sc_byte\n            }\n            sc_byte = sc_byte << 1\n            control.waitMicros(60)\n        }\n        return dat\n    }\n    //% block=\"value of DS18B20 %state at pin %pin\"\n    export function Ds18b20Temp(pin:DigitalPin,state:ValType):number{\n        init_18b20(pin)\n        write_18b20(pin,0xCC)\n        write_18b20(pin,0x44)\n        basic.pause(10)\n        init_18b20(pin)\n        write_18b20(pin,0xCC)\n        write_18b20(pin,0xBE)\n        low = read_18b20(pin)\n        high = read_18b20(pin)\n        temperature = high << 8 | low\n        temperature = temperature / 16\n        if(temperature > 130){\n            temperature = lastTemp\n        }\n        lastTemp = temperature\n        switch (state) {\n            case ValType.DS18B20_temperature_C:\n                return temperature\n            case ValType.DS18B20_temperature_F:\n                temperature = (temperature * 1.8) + 32\n                return temperature\n            default:\n                return 0\n        }\n\n    }\n    /**\n     * get dust value (μg/m³) \n     * @param vLED describe parameter here, eg: DigitalPin.P16\n     * @param vo describe parameter here, eg: AnalogPin.P1\n     */\n    //% blockId=\"readdust\" block=\"value of dust(μg/m³) at LED %vLED| out %vo\"\n    export function ReadDust(vLED: DigitalPin, vo: AnalogPin): number {\n        let voltage = 0;\n        let dust = 0;\n        pins.digitalWritePin(vLED, 0);\n        control.waitMicros(160);\n        voltage = pins.analogReadPin(vo);\n        control.waitMicros(100);\n        pins.digitalWritePin(vLED, 1);\n        voltage = pins.map(\n            voltage,\n            0,\n            1023,\n            0,\n            Reference_VOLTAGE\n        );\n        dust = (voltage - 380) * 5 / 29;\n        if (dust < 0) {\n            dust = 0\n        }\n        return Math.round(dust)\n\n    }\n\n\n    /**\n     * get Ultrasonic(sonar:bit) distance\n     * @param distance_unit describe parameter here, eg: 1\n     * @param pin describe parameter here, eg: DigitalPin.P16\n     */\n    //% blockId=readsonarbit block=\"Ultrasonic distance in unit %distance_unit |at|pin %pin\"\n    export function sonarbit_distance(distance_unit: Distance_Unit, pin: DigitalPin): number {\n\n        // send pulse\n        pins.setPull(pin, PinPullMode.PullNone)\n        pins.digitalWritePin(pin, 0)\n        control.waitMicros(2)\n        pins.digitalWritePin(pin, 1)\n        control.waitMicros(10)\n        pins.digitalWritePin(pin, 0)\n\n        // read pulse\n        let d = pins.pulseIn(pin, PulseValue.High, 23000)  // 8 / 340 = \n        let distance = d * 10 * 5 / 3 / 58\n\n        if (distance > 4000) distance = 0\n\n        switch (distance_unit) {\n            case 0:\n                return Math.round(distance) //mm\n                break\n            case 1:\n                return Math.round(distance / 10)  //cm\n                break\n            case 2:\n                return Math.round(distance / 25)  //inch\n                break\n            default:\n                return 0\n\n        }\n    }\n\n    let dht11Humidity = 0\n    let dht11Temperature = 0\n\n    /**\n     * get dht11 temperature and humidity Value\n     * @param dht11pin describe parameter here, eg: DigitalPin.P15\n     */\n    //% advanced=true\n    //% blockId=\"readdht11\" block=\"value of dht11 %dht11type| at pin %dht11pin\"\n    export function dht11value(dht11type: DHT11Type, dht11pin: DigitalPin): number {\n        const DHT11_TIMEOUT = 100\n        const buffer = pins.createBuffer(40)\n        const data = [0, 0, 0, 0, 0]\n        let startTime = control.micros()\n\n        if (control.hardwareVersion().slice(0, 1) !== '1') { // V2\n            // TODO: V2 bug\n            pins.digitalReadPin(DigitalPin.P0);\n            pins.digitalReadPin(DigitalPin.P1);\n            pins.digitalReadPin(DigitalPin.P2);\n            pins.digitalReadPin(DigitalPin.P3);\n            pins.digitalReadPin(DigitalPin.P4);\n            pins.digitalReadPin(DigitalPin.P10);\n\n            // 1.start signal\n            pins.digitalWritePin(dht11pin, 0)\n            basic.pause(18)\n\n            // 2.pull up and wait 40us\n            pins.setPull(dht11pin, PinPullMode.PullUp)\n            pins.digitalReadPin(dht11pin)\n            control.waitMicros(40)\n\n            // 3.read data\n            startTime = control.micros()\n            while (pins.digitalReadPin(dht11pin) === 0) {\n                if (control.micros() - startTime > DHT11_TIMEOUT) break\n            }\n            startTime = control.micros()\n            while (pins.digitalReadPin(dht11pin) === 1) {\n                if (control.micros() - startTime > DHT11_TIMEOUT) break\n            }\n\n            for (let dataBits = 0; dataBits < 40; dataBits++) {\n                startTime = control.micros()\n                while (pins.digitalReadPin(dht11pin) === 1) {\n                    if (control.micros() - startTime > DHT11_TIMEOUT) break\n                }\n                startTime = control.micros()\n                while (pins.digitalReadPin(dht11pin) === 0) {\n                    if (control.micros() - startTime > DHT11_TIMEOUT) break\n                }\n                control.waitMicros(28)\n                if (pins.digitalReadPin(dht11pin) === 1) {\n                    buffer[dataBits] = 1\n                }\n            }\n        } else { // V1\n            // 1.start signal\n            pins.digitalWritePin(dht11pin, 0)\n            basic.pause(18)\n\n            // 2.pull up and wait 40us\n            pins.setPull(dht11pin, PinPullMode.PullUp)\n            pins.digitalReadPin(dht11pin)\n            control.waitMicros(40)\n\n            // 3.read data\n            if (pins.digitalReadPin(dht11pin) === 0) {\n                while (pins.digitalReadPin(dht11pin) === 0);\n                while (pins.digitalReadPin(dht11pin) === 1);\n\n                for (let dataBits = 0; dataBits < 40; dataBits++) {\n                    while (pins.digitalReadPin(dht11pin) === 1);\n                    while (pins.digitalReadPin(dht11pin) === 0);\n                    control.waitMicros(28)\n                    if (pins.digitalReadPin(dht11pin) === 1) {\n                        buffer[dataBits] = 1\n                    }\n                }\n            }\n        }\n\n        for (let i = 0; i < 5; i++) {\n            for (let j = 0; j < 8; j++) {\n                if (buffer[8 * i + j] === 1) {\n                    data[i] += 2 ** (7 - j)\n                }\n            }\n        }\n\n        if (((data[0] + data[1] + data[2] + data[3]) & 0xff) === data[4]) {\n            dht11Humidity = data[0] + data[1] * 0.1\n            dht11Temperature = data[2] + data[3] * 0.1\n        }\n\n        switch (dht11type) {\n            case DHT11Type.DHT11_temperature_C:\n                return dht11Temperature\n            case DHT11Type.DHT11_temperature_F:\n                return (dht11Temperature * 1.8) + 32\n            case DHT11Type.DHT11_humidity:\n                return dht11Humidity\n        }\n    }\n\n    /**\n     * get pm2.5 value (μg/m³) \n     * @param pm25pin describe parameter here, eg: DigitalPin.P14\n     */\n    //% advanced=true\n    //% blockId=\"readpm25\" block=\"value of pm2.5(μg/m³) at pin %pm25pin\"\n    export function ReadPM25(pm25pin: DigitalPin): number {\n        let pm25 = 0\n        while (pins.digitalReadPin(pm25pin) != 0) {\n        }\n        while (pins.digitalReadPin(pm25pin) != 1) {\n        }\n        pm25 = input.runningTime()\n        while (pins.digitalReadPin(pm25pin) != 0) {\n        }\n        pm25 = input.runningTime() - pm25\n        return pm25;\n    }\n\n\n\n    /**\n     * get pm10 value (μg/m³) \n     * @param pm10pin describe parameter here, eg: DigitalPin.P13     \n     */\n    //% advanced=true\n    //% blockId=\"readpm10\" block=\"value of pm10(μg/m³) at pin %pm10pin\"\n    export function ReadPM10(pm10pin: DigitalPin): number {\n        let pm10 = 0\n        while (pins.digitalReadPin(pm10pin) != 0) {\n        }\n        while (pins.digitalReadPin(pm10pin) != 1) {\n        }\n        pm10 = input.runningTimeMicros()\n        while (pins.digitalReadPin(pm10pin) != 0) {\n        }\n        pm10 = input.runningTimeMicros() - pm10\n        pm10 = pm10 / 1000 - 2\n        return pm10;\n    }\n\n\n\n\n    /**\n     * get soil moisture value (0~100)\n     * @param soilmoisturepin describe parameter here, eg: AnalogPin.P1\n     */\n    //% blockId=\"readsoilmoisture\" block=\"value of soil moisture(0~100) at pin %soilhumiditypin\"\n    export function ReadSoilHumidity(soilmoisturepin: AnalogPin): number {\n        let voltage = 0;\n        let soilmoisture = 0;\n        voltage = pins.map(\n            pins.analogReadPin(soilmoisturepin),\n            0,\n            1023,\n            0,\n            100\n        );\n        soilmoisture = voltage;\n        return Math.round(soilmoisture)\n    }\n\n\n    /**\n     * get light intensity value (0~100)\n     * @param lightintensitypin describe parameter here, eg: AnalogPin.P1\n     */\n    //% blockId=\"readlightintensity\" block=\"value of light intensity(0~100) at pin %lightintensitypin\"\n    export function ReadLightIntensity(lightintensitypin: AnalogPin): number {\n        let voltage = 0;\n        let lightintensity = 0;\n        voltage = pins.map(\n            pins.analogReadPin(lightintensitypin),\n            0,\n            1023,\n            0,\n            100\n        );\n        lightintensity = voltage;\n        return Math.round(lightintensity)\n    }\n\n\n    /**\n     * get water level value (0~100)\n     * @param waterlevelpin describe parameter here, eg: AnalogPin.P1\n     */\n    //% blockId=\"readWaterLevel\" block=\"value of water level(0~100) at pin %waterlevelpin\"\n    export function ReadWaterLevel(waterlevelpin: AnalogPin): number {\n        let voltage = 0;\n        let waterlevel = 0;\n        voltage = pins.map(\n            pins.analogReadPin(waterlevelpin),\n            0,\n            700,\n            0,\n            100\n        );\n        waterlevel = voltage;\n        return Math.round(waterlevel)\n    }\n\n\n\n    /**\n     * get wind speed value (m/s)\n     * @param windspeedpin describe parameter here, eg: AnalogPin.P1\n     */\n    //% advanced=true\n    //% blockId=\"readwindspeed\" block=\"value of wind speed(m/s) at pin %windspeedpin\"\n    export function ReadWindSpeed(windspeedpin: AnalogPin): number {\n        let voltage = 0;\n        let windspeed = 0;\n        voltage = pins.map(\n            pins.analogReadPin(windspeedpin),\n            0,\n            1023,\n            0,\n            Reference_VOLTAGE\n        );\n        windspeed = voltage / 40;\n        return Math.round(windspeed)\n    }\n\n\n\n    /** \n     * get noise value (dB)\n     * @param noisepin describe parameter here, eg: AnalogPin.P1\n     */\n    //% blockId=\"readnoise\" block=\"value of noise(dB) at pin %noisepin\"\n    export function ReadNoise(noisepin: AnalogPin): number {\n        let level = 0\n        let voltage = 0\n        let noise = 0\n        let h = 0\n        let l = 0\n        let sumh = 0\n        let suml = 0\n        for (let i = 0; i < 1000; i++) {\n            level = level + pins.analogReadPin(noisepin)\n        }\n        level = level / 1000\n        for (let i = 0; i < 1000; i++) {\n            voltage = pins.analogReadPin(noisepin)\n            if (voltage >= level) {\n                h += 1\n                sumh = sumh + voltage\n            } else {\n                l += 1\n                suml = suml + voltage\n            }\n        }\n        if (h == 0) {\n            sumh = level\n        } else {\n            sumh = sumh / h\n        }\n        if (l == 0) {\n            suml = level\n        } else {\n            suml = suml / l\n        }\n        noise = sumh - suml\n        if (noise <= 4) {\n            noise = pins.map(\n                noise,\n                0,\n                4,\n                30,\n                50\n            )\n        } else if (noise <= 8) {\n            noise = pins.map(\n                noise,\n                4,\n                8,\n                50,\n                55\n            )\n        } else if (noise <= 14) {\n            noise = pins.map(\n                noise,\n                9,\n                14,\n                55,\n                60\n            )\n        } else if (noise <= 32) {\n            noise = pins.map(\n                noise,\n                15,\n                32,\n                60,\n                70\n            )\n        } else if (noise <= 60) {\n            noise = pins.map(\n                noise,\n                33,\n                60,\n                70,\n                75\n            )\n        } else if (noise <= 100) {\n            noise = pins.map(\n                noise,\n                61,\n                100,\n                75,\n                80\n            )\n        } else if (noise <= 150) {\n            noise = pins.map(\n                noise,\n                101,\n                150,\n                80,\n                85\n            )\n        } else if (noise <= 231) {\n            noise = pins.map(\n                noise,\n                151,\n                231,\n                85,\n                90\n            )\n        } else {\n            noise = pins.map(\n                noise,\n                231,\n                1023,\n                90,\n                120\n            )\n        }\n        noise = Math.round(noise)\n        return Math.round(noise)\n    }\n\n    //% block=\"value of BME280 %state\"\n    export function octopus_BME280(state: BME280_state): number {\n        switch (state) {\n            case 0:\n                get();\n                return Math.round(T);\n                break;\n            case 1:\n                get();\n                return Math.round(H);\n                break;\n            case 2:\n                get();\n                return Math.round(P / 100);\n                break;\n            case 3:\n                get();\n                return Math.round(1015 - (P / 100)) * 9\n                break;\n            default:\n                return 0\n        }\n        return 0;\n    }\n    /**\n    * TODO: Detect soil moisture value(0~100%)\n    * @param soilmoisturepin describe parameter here, eg: DigitalRJPin.J1\n    */\n    //% blockId=\"PIR\" block=\"PIR sensor %pin detects motion\"\n    export function PIR(pin: DigitalPin): boolean {\n        if (pins.digitalReadPin(pin) == 1) {\n            return true\n        }\n        else {\n            return false\n        }\n    }\n        /**\n    * get UV level value (0~15)\n    * @param waterlevelpin describe parameter here, eg: AnalogRJPin.J1\n    */\n    //% blockId=\"readUVLevel\" block=\"UV sensor %Rjpin level(0~15)\"\n    export function UVLevel(pin: AnalogPin): number {\n        let UVlevel = pins.analogReadPin(pin);\n        if (UVlevel > 625) {\n            UVlevel = 625\n        }\n        UVlevel = pins.map(\n            UVlevel,\n            0,\n            625,\n            0,\n            15\n        );\n        return Math.round(UVlevel)\n    }\n        /**\n    * toggle led\n    */\n    //% blockId=LED block=\"LED %pin toggle to $ledstate || brightness %brightness \\\\%\"\n    //% brightness.min=0 brightness.max=100\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% expandableArgumentMode=\"toggle\"\n    export function ledBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 100): void {\n        if (ledstate) {\n            pins.analogSetPeriod(pin, 100)\n            pins.analogWritePin(pin, Math.map(brightness, 0, 100, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 0)\n            brightness = 0\n        }\n    }\n\n    //% block=\"RFID sensor IIC port read data from card\"\n    export function readDataBlock(): string {\n        if (NFC_ENABLE === 0) {\n            wakeup();\n        }\n        if (checkCard() === false) {\n            serial.writeLine(\"No NFC Card!\")\n            return \"\"\n        }\n        if (!passwdCheck(uId, passwdBuf)) {\n            serial.writeLine(\"passwd error!\")\n            return \"\";\n        }\n        let cmdRead: number[] = []\n        cmdRead = [0x00, 0x00, 0xff, 0x05, 0xfb, 0xD4, 0x40, 0x01, 0x30, 0x07, 0xB4, 0x00];\n        let sum = 0, count = 0;\n        cmdRead[9] = block_def;\n        for (let i = 0; i < cmdRead.length - 2; i++) {\n            if ((i === 3) || (i === 4)) {\n                continue;\n            }\n            sum += cmdRead[i];\n        }\n        cmdRead[cmdRead.length - 2] = 0xff - sum & 0xff;\n        let buf = pins.createBufferFromArray(cmdRead)\n        writeAndReadBuf(buf, 31);\n        let ret = \"\";\n        if ((recvBuf[6] === 0xD5) && (recvBuf[7] === 0x41) && (recvBuf[8] === 0x00) && (checkDcs(31 - 4))) {\n            for (let i = 0; i < 16; i++) {\n                if (recvBuf[i + 9] >= 0x20 && recvBuf[i + 9] < 0x7f) {\n                    ret += String.fromCharCode(recvBuf[i + 9]) // valid ascii\n                }\n            }\n            return ret;\n        }\n        return \"\"\n    }\n    //% block=\"RFID sensor IIC port write %data to card\"\n    export function writeData(data: string): void {\n        let len = data.length\n        if (len > 16) {\n            len = 16\n        }\n        for (let i = 0; i < len; i++) {\n            blockData[i] = data.charCodeAt(i)\n        }\n        writeblock(blockData);\n    }\n    //% block=\"RFID sensor IIC port Detect Card\"\n    export function checkCard(): boolean {\n        if (NFC_ENABLE === 0) {\n            wakeup();\n        }\n        let buf: number[] = [];\n        buf = [0x00, 0x00, 0xFF, 0x04, 0xFC, 0xD4, 0x4A, 0x01, 0x00, 0xE1, 0x00];\n        let cmdUid = pins.createBufferFromArray(buf);\n        writeAndReadBuf(cmdUid, 24);\n        for (let i = 0; i < 4; i++) {\n            if (recvAck[1 + i] != ackBuf[i]) {\n                return false;\n            }\n        }\n        if ((recvBuf[6] != 0xD5) || (!checkDcs(24 - 4))) {\n            return false;\n        }\n        for (let i = 0; i < uId.length; i++) {\n            uId[i] = recvBuf[14 + i];\n        }\n        if (uId[0] === uId[1] && uId[1] === uId[2] && uId[2] === uId[3] && uId[3] === 0xFF) {\n            return false;\n        }\n        return true;\n    }\n\n\n}\n\n","pxt.json":"{\n    \"name\": \"Environment-and-Science-IoT\",\n    \"version\": \"5.2.0\",\n    \"description\": \"Environment and Science IoT Kit for micro:bit\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"SSD1306_OLED\": \"github:tinkertanker/pxt-oled-ssd1306#v2.0.13\",\n        \"ds1307\": \"github:elecfreaks/pxt-ds1307-rtc\",\n        \"ESP8266_IoT\": \"github:cordx56/pxt-esp8266iot#add-type\"\n    },\n    \"files\": [\n        \"environment.ts\",\n        \"README.md\",\n        \"_locales/zh/Environment-and-Science-IoT-strings.json\"\n    ],\n    \"testFiles\": [\n        \"tests.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"4.0.18\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","tests.ts":""}